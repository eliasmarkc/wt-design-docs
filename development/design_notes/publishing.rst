.. _publishing_tales:

Tale Publishing
===============

What Gets Saved
---------------

Yes:

- Workspace files
- External HTTP files
- Tale's license
- Tale's manifest
- Tale's docker environment (tar.gz)

No:

- Registered Data (external). We save the URIs instead.

Implementation
--------------

girder_wholetale
~~~~~~~~~~~~~~~~
An endpoint, ``publish``, was added to the REST API with a sub-endpoint, ``dataone``.
When the endpoint is called, it launches a celery job (code is in gwvolman) 
to start publishing the Tale.

dashboard
~~~~~~~~~

The UI related features to publishing are fairly contained. The publishing modal 
dialog was written as a component and resides in `components/ui/file/publish-modal`. 
The logic for opening the modal is contained in the ``run/left-panel`` component.


DataONE JWT
***********
The DataONE JWT is needed for the backend to authenticate writes to DataONE and to 
get important information about the user, such as the ORCID. It is obtained by 
querying the DataONE CN, which is https://cn-stage-2.test.dataone.org/portal/token 
for dev and https://cn.dataone.org/portal/token for production.

The authentication code should reside in the ``dataone-auth.js`` service, and can 
be called from other components if needed. The logic for deciding whether to ask 
the production coordinating node for the token is dictated by the ENV.dev flag.

Default Items Accordion
***********************
The accordion in the publishing modal that lists default items is generated by 
an array of strings in the publishing modal component. 

To add files to the accordion, add the name of the file to the array (can be found with a string search of other 
non-optional files). To add a tooltip, add a popup to ``create_tooltips()``, you can 
use existing popups as examples.

Progressbar
***********
The publishing code handles the progress state and transmits it to the UI via progress 
updates. The progressbar updates its state based on the contents of update messages sent by the 
job system. The method that handles this logic can be found as ``handlePublishingStatus()``.


gwvolman
~~~~~~~~

Startup
*******

The publishing portion of code is defined as a celery task in gwvolman. 
When the task is started, the girder and DataONE clients are initialized. The girder 
client is used to query Wholetale for files and metadata. The DataONE client is 
used to create the system metadata and upload objects to DataONE.

Tale Item Filtering
*******************

After the clients have been initialized, the Tale's workspace and dataSet are 
examined and filtered into a few lists. These lists are used in a number of ways:

1. To give an estimate of file upload progress (ie current_file/total_files)
2. Items in the `local_items` list are uploaded to DataONE
3. Items in the `remote` list are uploaded to DataONE
4. The EML record creation code iterates and adds records for each element in the lists


Uploading the License
*********************

The Tale has the license SPDX defined as a property. The Girder Client is used
to query the license endpoint for the Tale's license. Once obtained the text is 
uploaded to DataONE. This can be used as a template for uploading other external 
files to the package.


Generating EML
**************

The EML XML document is parsed by the DataONE UI and is responsible for the content under
the ``General`` section. Python's eTree is used in conjunction with helper functions 
defined in `gwvolman/dataone_metadata.py` to generate this document. It takes a 
list of all of the items that are included in the package, their sizes, and information 
about the user and organizes relevant information about them in EML.

The Tale manifest, license, and repository are also added to the record after the 
user's items are added.

MIME Type Checking
******************
DataONE has strict rules on the file types of uploaded objects. If an unsupported 
file type is uploaded, the coordinating node won't properly index the dataset. To
account for this, the supported formats are taken from https://cn.dataone.org/cn/v2/formats.
During each file upload, the type is checked against the supported list. If the 
type isn't supported, it it defaulted to `application/octet-stream`.


md5 Hashing
***********
DataONE's system metadata requires a hash of the file being uploaded. This can be either
sha1 or md5. Girder has a hash for each file however, DataONE has no plan on supporting it.


Adding a Custom File to a Package
*********************************

Adding a custom file (manifest, LICENSE, etc) can be done in a few steps.

1. Create a method, `upload_<name>_file`
2. Inside that method create the pid and metadata
3. Upload the file
4. Return the pid and the size of the file
5. Add the pid to the ``upload_object_pids`` list
6. Add the file size to the ``file_sizes`` dict
7. Add a section for the file in the EML document ``create_minimum_eml``


Troubleshooting
***************


If you see a package with an issue in the `General` section, the problem most is most 
likely in the EML document since the UI parses it.

If you see a package with a blank `Files in this dataset` section, there was an issue with 
the resource map. This can range from reference an out-of-network dataone obbject, incorrect hash,
unsupported mimetype, or mangled RDF.

If you see a package with missing files, make sure that the file exists in the structure
returned by `gwvolman.utils.filter_items`. Next track how the object is used (is it a local item, remote, etc. where are they used).